<link rel="stylesheet" href="/css/writing.css">
<form method="post" name="new" onsubmit="copy()">
	<fieldset>
		<h1><input id="title" spellcheck="false" autocomplete="off" name="title" value="{{ .Data.Title }}"></h1>
		{{if Markdown}}
		<script src="/js/he.js"></script>
		<script src="/js/to-markdown.js"></script>
		<textarea class="markdown" name="markdown" id="text"></textarea>
		<script type="text/javascript">
			document.getElementById("text").value = toMarkdown({{ unescape .Data.Content }})
		</script>
		{{else}}
		<textarea class="hidden" name="content"></textarea>
		<section id="text" contenteditable="true">{{ unescape .Data.Content }}</section>
		{{end}}
		<input type="submit" value="Update" />
	</fieldset>
</form>
<script type="text/javascript">

	// These functions are analogous to the ones in /post/new.tmpl
	// If this is your first time reading this code, I suggest to look at the
	// file mentioned above first. It should be a bit more clear.
	
	// LocalStorage loops(?) to save both post title and content to cache.
	// Looks ugly, but better than AJAX based failover, right?
	// Modified version of this: https://gist.github.com/addyosmani/d1f3ca715ac902788c2d
	{{if Markdown}}

	with({
		l: localStorage, // Alias for localStorage, where we'll store text content
	// This is some sort of variable initialization. It also checks whether there is anything in cache already.
	}) with(document.getElementById("text")) if (l[{{ .Data.Slug }}] != null) {
		value = l.getItem({{ .Data.Slug }}), // Replace placeholder text with localstorage content.
		oninput = function () {
			l[{{ .Data.Slug }}] = value // Save HTML context to localStorage.
		}
	} else {
		oninput = function () {
			l[{{ .Data.Slug }}] = value
		}
	}

	{{else}}

	with({
		l: localStorage, // Alias for localStorage, where we'll store text content
	// This is some sort of variable initialization. It also checks whether there is anything in cache already.
	}) with(document.getElementById("text")) if (l[{{ .Data.Slug }}] != null) {
		innerHTML = l.getItem({{ .Data.Slug }}), // Replace placeholder text with localstorage content.
		oninput = function () {
			l[{{ .Data.Slug }}] = innerHTML // Save HTML context to localStorage.
		}
	} else {
		oninput = function () {
			l[{{ .Data.Slug }}] = innerHTML
		}
	}

	{{end}}

	// For a yet another unknown reason we need two instances of localstorage.
	// Fundamentally analogous to the loop above.
	with({
		l2: localStorage,
	}) with(document.getElementById("title")) if (l2[{{ .Data.Title }}] != null) {
		document.new.title.value = l2.getItem({{ .Data.Title }}),
		oninput = function () {
			l2[{{ .Data.Title }}] = document.new.title.value
		}
	} else {
		oninput = function () {
			l2[{{ .Data.Title }}] = document.new.title.value
		}
	}

	// Copy data from contenteditable to textarea for POST to gather the data correctly.
	// Also clear localstorage.
	function copy() {
		localStorage.removeItem({{ .Data.Slug }});
		localStorage.removeItem({{ .Data.Title }});
		var html = document.getElementById("text").innerHTML;
		{{if Markdown}}
		{{else}}
		document.new.content.value = html;
		{{end}}
		return
	}
</script>
